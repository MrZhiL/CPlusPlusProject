1.2 函数模板

	C++另一种编程思想称为 泛型编程 ，主要利用的技术就是模板
	C++提供两种模板机制：函数模板和类模板
	
	1.2.1 函数模板语法
	
		函数模板的作用：建立一个通用函数，其函数返回值类型和形参类型不具体指定，用一个虚拟的类型来代表。
		
		语法： template<typename T> 
			   函数声明或定义
			   
		解释；template -- 声明创建模板
			  typename -- 表明其后面的符号是一种数据类型，可以用class代替
			  T --- 通用的数据类型，名称可以替换，通常为大写字母 
			  
			  
	1.2.2 函数模板注意事项
		
		1、自动类型推导，必须推导出一致的数据类型T，才可以使用
		2、模板必须要确定出T的数据类型，才可以使用 
			  
	1.2.3 函数模板案例
		
		案例描述：1、利用函数模板封装一个排序的函数，可以对不同数据类型数组进行排序
				  2、排序规则从小到大，排序算法为选择排序
				  3、分别利用char数组和int数组进行测试 
		
	1.2.4 普通函数和函数模板的区别
		
		普通函数和模板函数的区别：1、普通函数调用时可以发生自动类型转换（隐式类型转换）
								  2、函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换
								  3、如果利用显示指定类型的方式，可以发生隐式类型转换
	
		
	1.2.5 普通函数和模板函数的调用规则
	
		1、如果函数模板和普通函数都可以实现，优先调用普通函数
		2、可以通过空模板参数列表来强调函数模板
		3、函数模板也可以发生重载
		4、如果函数模板可以产生更好的匹配，优先调用函数模板	
		
	1.2.6 函数模板的局限性
	
		// 函数模板的局限性: 模板的通用性并不是万能的
		// 例如：template<class T>
		//       void f(T a, T b) { a = b; }
		// 在上述代码中提供的赋值操作，如果传输的为数组则无法实现
		
		// 在例如：template<class T>
		//         void f(T a, T b){ 
		//		 		if(a>b) {...} 
		//			} 
		// 在上述代码中，如果T的数据类型传输的像是Person这样的自定义数据类型，也无法正常运行 
		
		// 因此C++为了解决这种问题，提供了模板的重载，可以为这些特定的类型提供具体的模板 
	
		
	
	1.3 类模板
	
	1.3.1 类模板的语法
		
		类模板的作用：建立一个通用类，类中的成员 数据类型可以不具体制定，用一个虚拟的类型来代表
		 
		语法： template<typename/class T>
			   类
	    解释：template---声明创建模板，typename/class---表示其后面的符号是一种数据类型，可以用class代替
			  T---通用的数据类型，名称可以替换，通常为大写字母
	
		：：：类模板和函数模板的语法非常相似，在声明template后面加类，称为类模板	
		
		类模板和函数模板的区别： 
		 1、类模板没有自动类型推导的使用方式
		 2、类模板在模板参数列表中可以有默认参数 
		
	
	1.3.2 类模板中成员函数创建时机
		
		类模板中成员函数和普通类中成员函数创建时机是有区别的：
			1、普通类中的成员函数一开始就可以创建
			2、类模板中的成员函数在调用时才创建
		
	1.3.3 类模板中成员函数创建时机
	
		类模板中的成员函数的创建 与 普通成员函数的创建是有区别的：
		1、普通成员函数在一开始就可以创建
		2、类模板中的成员函数在使用时才创建
	
	1.3.4 类模板对象做函数参数
	
		学习目标：模板实例化出的对象，向函数传参的方式
		
		一共有三种传入方式：
		1、指定传入的类型 -- 直接显示对象的数据类型
		2、参数模板化 	  -- 将对象中的参数变为模板进行传递
		3、整个类模板化   -- 将这个对象类型 模板化进行传递	
		
	1.3.7 类模分文件的编写	
		
		学习目标：掌握类模板成员函数的分文件编写产生的问题以及解决方式
		
		问题：类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到
		
		解决：1、直接包含.cpp源文件
			  2、将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制 
		
		
		
		
2、STL初识

	2.1 STL的诞生
		
		*长久以来，软件界一直希望建立一种可重复利用的东西
		*C++的面向对象和泛型编程思想，目的就是复用性的提升
		*大多情况下，数据结构和算法都未能有一套标准，导致被迫从事大量重复工作
		*为了建立数据结构和算法的一套标准，诞生了STL
		
	2.2 STL基本概念
	
		1、STL（Standard Template Library，标准模板库）		
		2、STL从广义上分为：容器（container）、算法（algorithm）、迭代器（iterator） 
		3、容器和算法之间通过迭代器进行无缝连接
		4、STL几乎所有的代码都采用了模板类或模板函数
		
		
	2.3 STL六大组件
	
		 STL大体分为六大组件，分别是：容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器
		 
		 1、容器：各种数据结构，如vector、list、deque、set、map等，用来存放数据
		 2、算法：各种常用的算法，如sort、find、copy、for_each等 
		 3、迭代器：扮演了容器和算法之间的胶合剂 
		 4、仿函数：行为类似函数，可作为算法的某种策略 
		 5、适配器：一种用来修饰容器或者仿函数或迭代器接口的东西 
		 6、空间配置器：负责空间的配置和管理 
		
	2.4 STL中容器、算法、迭代器
	
		容器：置物之所也
		
			STL容器就是将运用最广泛的一些数据结构实现出来 
			
			常用的数据结构：数组、链表、树、栈、队列、集合、映射表　等
			
			这些容器分为序列式容器和关联式容器两种：
				
				序列式容器：强调值的排序，序列式容器中的每个元素均有固定的位置 
				关联式容器：二叉树结构，各元素之间没有严格要求的物理上的顺序关系
			
		算法：问题之解法也
		
			有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法（Algorithms）
			
			算法分为：质变算法和非质变算法： 
			
				质变算法： 是指运算过程中会更改区间内的元素的内容。例如拷贝、替换、删除等等
				非质变算法：是指运算过程中不会更改区间内容的元素内容，例如查找、计数、遍历、寻找极值等等。
				
		迭代器：容器和算法之间粘合剂
			
			提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表达方式。
			
			每个容器都有自己专属的迭代器
			
			迭代器使用非常类似于指针，初学阶段我们可以先理解为指针 
		
		迭代器种类：
			
			种类			功能					支持运算
			输入迭代器		对数据的只读访问 				只读，支持++、==、!= 
			输出迭代器		对数据的只写访问 				只写，支持++ 
			前向迭代器		读写操作，并能向前推进迭代器 			读写，支持++、==、!= 
			双向迭代器		读写操作，并能向前和先后操作 			读写，支持++、-- 
			随机访问迭代器	读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器  读写，支持++、--、[n]、-n、<、<=、>、>= 
		
			常用的容器中迭代器种类分为双向迭代器，和随机访问迭代器 
		
		
	2.5 容器算法迭代器初始
	
		了解STL中容器、算法、迭代器概念之后，我们利用代码感受一下。
		STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器
		
		2.5.1 Vector存放内置数据类型
			
			容器：vector	
			算法：for_each
			迭代器：vextor<int>::iterator 
		
		2.5.2 Vector存放自定义数据类型
		
		2.5.3 容器嵌套容器
		
			


3、 STL-常用容器	

	3.1 string容器 
		
		3.1.1 string基本概念
			
			本质：string是C++风格的字符串，二string本质上是一个类
			
			string 和 char* 的区别：
				char*是一个指针
				string是一个类，类内封装了char*，管理这个字符串，是一个char*型的容器
				
			特点：string类内封装了很多成员方法
			
				例如：查找find，拷贝copy，删除delete，替换replace，插入insert
				
				string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责
	
		3.1.2 string构造函数
			
			构造函数原型：
				string();					// 创建一个空的字符串，例如string str; 
				string(const char* s);		// 使用字符串s初始化 
				
				string(const string &str);	// 使用一个string对象初始化另一个string对象 
				
				string(int n, char c); 		// 使用n个字符c初始化 
				
			
		3.1.3 string赋值操作
	
			功能描述：给string字符串进行赋值
			
			赋值的函数原型：
				string& operator=(const char* s);			//char*类型字符串 赋值给当前的字符串
				string& operator=(const string &s);			//把字符串s赋给当前的字符串
				string& operator=(char c);					//将char字符c赋值给当前字符串
				string& assign(const char* s);				//把字符串s赋给当前的字符串
				string& assign(const char* s, int n);		//把字符串的前n个字符赋值给当前的字符串
				string& assign(const char &s);				//把字符串s赋值给当前的字符串
				string& assign(int n, char c);				//把n个字符c赋值给当前字符串
			
			总结：string赋值的方式有很多，operator= 这种方式多一些
			
		3.1.4 string字符串拼接
				
			功能描述：实现在字符串末尾拼接字符串
			
			函数原型：
				string& operator+=(const char* c);			//重载+=运算符
				string& operator+=(const string &str);		//重载+=运算符
				string& operator+=(char c);					//重载+=运算符
				string& append(const string *str);			//把字符串str连接到当前字符串的末尾
				string& append(const char* s, int n);		//把字符串的前n个字符连接到当前字符串的末尾
				string& append(const string &s);			//把字符串s连接到当前字符串的末尾
				string& append(const string &s, int pos, int n);//把字符串s中从pos开始的n个字符连接到字符串末尾
			
			总结：
			
			
		3.1.5 string字符串的替换和查找	
			
			功能描述：查找：查找指定字符串是否存在
					  替换：在指定的位置替换字符串
					  
			函数原型：
				int find(const string& str, int pos=0) cosnt ;			//查找str第一次出现位置，从pos开始查找
				int find(const char *s, int pos=0) const;				//查找s第一次出现位置，从pos开始查找
				int find(const char *s, int pos, int n) cosnt;			//从pos位置查找s的前n个字符第一次位置
				int find(const char c, int pos=0) const;				//查找字符c第一次出现的位置
				int rfind(const string &str, int pos=npos) const;		//查找str最后一次位置，从pos开始查找
				int rfind(const char *s, int pos=npos) cosnt;			//查找s最后一次出现位置，从pos开始查找
				int rfind(const char *s, int pos ,int n) const;			//从pos查找s的前n个字符最后一次位置
				int rfind(cosnt char c, int pos = 0) const;				//查找字符c最后一次出现位置
				
				string& replace(int pos, int n, const string& str);		//替换从pos开始n个字符为字符串str
				string& replace(int pos, int n, const char *s);			//替换从pos开始的n个字符为字符串s
			
			rfind和find的区别：rfind从左往右查找，find从右往左查找，但都从左往右计算。 
			
			
			3.1.6 string字符串比较
				
				功能描述：字符串之间的比较
				
				比较方式：字符串比较是按字符的ASCII码进行对比。
						　如果相等(=)，则返回０; 如果大于(>)，则返回1；如果小于(<)，则返回-1
				
				函数原型：int compare(const string &s) const; //与字符串s比较
						  int compare(const char *s) const;	  //与字符串s比较 
				 
				总结：字符串的对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大。 
			
					
			3.1.7 string字符存取
				
				string中单个字符存取方式有两种：char& operator[](int n); // 通过[]方式取字符 
												char& at(int n); 		 // 通过at方式获取字符 
			
			3.1.8 string插入和删除
				
				功能描述：对string字符串进行插入和删除字符操作
				
				函数原型：string& insert(int pos, const string& str); 	// 插入字符串str
				 		  string& insert(int pos, const char* s); 		// 插入字符串s
				 		  string& insert(int pos, int n, char c);       // 在指定位置插入n个字符c
						  string& erase(int pos, int n = npos);			// 删除从pos开始的n个字符
						   
				总结：字符的插入和删除的起始下标都是从0开始		
			
			3.1.9 string字串获取：
				
				功能描述：从字符串种获取想要的字串
				
				函数原型：string substr(int pos=0, int n = npos) const; // 返回由pos开始的n个字符组成的字符串 
			
				总结：灵活运用求字串功能，可以在实际开发中获取有效的信息 
			

	3.2 vectot容器
		
		3.2.1 vector基本概念
			
			功能：vector数据结构和数组非常相似，也称为单端数组
			
			vector与普通数组的区别：不同之处在于数组是静态空间，而vector可以动态扩展 
		
			动态扩展：并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝到新空间，释放原空间 
		
			vectot容器的迭代器是支持随机访问的迭代器 
			
		
		3.2.2 vector构造函数
			
			功能描述：创建vector容器。
			
			函数原型：vector<T> v;						//采用模板类实现，默认构造函数 
					  vector<v.begin(), v.end());		//将[v.begin(),v.end())区间(前闭后开)中的元素拷贝给自身 
					  vector(n, elem);					//构造函数将n个elem拷贝给本身 
					  vector(const vector &vec); 		//拷贝构造函数 
		 	总结：vector的多种构造方式没有可比性，灵活使用即可
			 
		3.2.3 vector赋值操作
		
			功能描述：给vector容器进行赋值
			
			函数原型：vector& operator=(const vector &vec);	//重载等号操作符
					  assign(beg, end);			// 将[beg, end)区间中大的数据拷贝赋值给本身 
					  assign(n, elem); 			// 将n个elem数据赋值给本身
			 
			 总结：vector赋值方式比较简单，使用operator=,或assign都可以
			 
		3.2.4 vector容量和大小
		
			功能描述：对vector容器的容量和大小操作
			
			函数原型：empty();					// 判断容器是否为空 
					  capacity();				// 容器的容量(总的可以存储的数据大小,大于等于size) 
					  size();					// 返回容器中元素的个数 
					  resize(int num);			// 重新指定容器的长度为num，若容器变长，则以默认值填充新位置 
											 	// 如果容器变短，则末尾超出容器长度的元素被 删除 
					  
					  resize(int num, elem);	// 重新指定容器的长度为num，若容器变长，则以elem填充新位置 
											 	// 如果容器变短，则末尾超出容器长度的元素被 删除 
					  
					  
		3.2.5 vector容器的插入和删除
			
			功能描述：对vector容器进行插入、删除操作
			
			函数原型： 	   push_back(ele);					//在尾部插入元素ele 
					   pop_back();					//删除最后一个元素 
					   insert(const_iterator pos, ele);			//在迭代器指定位置pos插入元素ele 
					   insert(cosnt_iterator pos, int count, ele);		//在迭代器指定位置pos插入count个ele 
					   erase(const_iterator pos);				//删除迭代器指定位置pos的元素 
					   erase(const_iterator start, const_iterator end);		//删除迭代器从start到end之间的元素 
					   clear();						//删除容器中所有元素 
				
		3.2.6 vector数据获取
			
			功能描述：对vector中的数据的存取操作
			
			函数原型：at(int idx);		//返回索引idx所指的数据 
					  operator[];		//返回索引idx所指的数据 
					  front();			//返回容器中第一个数据元素 
					  back();			//返回容器中最后一个数据元素 
				
			总结：除了用迭代器获取vector容器中的元素，[]和at也可以		
				
		3.2.7 vector互换容器
			
			功能描述：实现两个容器内元素进行互换
			
			函数原型：swap(vec); // 将vec与本身的元素互换		
				
			总结：swap可以使两个容器互换，可以达到实用的收缩内存效果，例如：
			
				vector<int> vec;
				for(int i=0; i<100000; i++){		// 此时vec的大小为100000，容量为130000 
					vec.push_back(i);
				}	
				vec.resize(10);						// 进行大小重设后，大小为10，容量不变，仍未13000
				vector<int>(vec).swap(vec);			// 表示先创建一个匿名容器x，x(vec)表示进行拷贝构造函数，再将x与vec进行容器互换，之后将匿名容器进行销毁 
													// 此时vec的大小为10，容量为10，大大收缩了无用的内存空间 
				
		3.2.8 vector预留空间
			
			功能描述：减少vector在动态扩展容量时的扩展次数
			
			函数原型：reserve(int len); // 容器预留len个元素长度，预留位置不初始化，元素不可访问 
			
			总结：如果数据量级较大，可以一开始利用reserve()函数预留空间 
	
	3.3 deque容器
		
		3.3.1 deque容器基本概念
			
			功能：双端数组，可以对头端进行插入和删除操作
			
			deque和vector的区别：
				vector对于头部的插入删除效率低，数据量越大，效率越低
				deque相对而言，对头部的插入删除速度比vector快
				vector访问元素时的速度会比deque快，这和两者内部实现有关 
	
			deque内部工作原理: deque内部有个中控器，维护每段缓冲区中的内容，缓冲区中存放展示数据
							   中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间
		   
		    deque访问元素较慢的原因在于：deque访问元素时，需要先找到该元素的缓冲区，然后deque通过缓冲区去寻找该元素
			
			deque容器的迭代器也支持随机访问 
	
		3.3.2 deque构造函数
		
			功能描述：deque容器构造
				
			函数原型：deque<T> deqT;		   // 默认构造形式 
					  deque(beg,end)		   // 构造函数将[beg,end)区间中的元素拷贝给自身 
					  deque(n,elem);		   // 构造函数将n个elem元素拷贝给自身 
					  deque(const deque &deq); // 拷贝构造函数 
			
			总结：deque容器和vector容器构造方式几乎一样，灵活使用即可 
	
		3.3.3 deque赋值操作
		
			功能描述：给deque容器进行赋值
			
			函数原型：deque& operator=(const deque& deq);	// 重载operator=操作符 
					  assign(beg, end);						// 将deque容器中的[beg，end)中的数据赋值给本身 
					  assign(n,elem); 						// 将n个elem元素赋值给本身 
	
			总结：deque容器的赋值操作和vector容器也基本一样，灵活掌握即可
			
		3.3.4 deque大小操作
		
			功能描述：对deque容器的大小进行操作
			
			函数原型：deque.empty();			//判断容器是否为空 
					  deque.size();				//判断容器的大小，并返回元素的个数 
					  deque.resize(num);		//重新指定容器的长度为num，若容器边长，则以默认值填充新位置
					  							//若容器变小，则末尾超出容器长度的元素被删除 
					  deque.resize(num,elem);   //重新指定容器的长度为num，若容器边长，则以elem填充新位置
					  							//若容器变小，则末尾超出容器长度的元素被删除 
					  // deque.capacity(); 没有改函数，因为deque中没有容量限制，deque维护的是缓冲区，其中可以前后插入 
	
	
		3.3.5 deque容器的插入和删除
		
			功能描述：向deque容器中插入和删除数据
			
			函数原型：
				两端插入操作 
					  push_back(elem);		//在容器末端插入元素elem（尾插法） 
					  push_front(elem);		//在容器首段插入元素elem（头插法） 
					  pop_back();			//在容器末尾删除一个元素（尾删法） 
					  pop_front();			//删除容器中最前端的元素（头删法） 
				指定位置操作：
					  insert(pos, elem);	//在pos位置插入元素elem,并返回新数据的位置 
					  insert(pos, n, elem) ;//在pos位置插入n个elem元素，无返回值 
					  insert(pos, beg, end);//在pos位置插入[beg,end)区间的数据，无返回值 
					  clear();				//情况容器中的所有数据 
					  erase(beg, end);		//情况容器中[beg,end)区间的数据，返回下一个数据的位置 
					  erase(pos);			//删除pos位置的数据，返回下一个数据的位置
					  
				 
			总结：1、插入和删除提供的位置是迭代器@@@
	
		3.3.6 deque数据存取
		
			功能描述：对deque中的数据的存取操作
			
			函数原型：at(int idx);	//返回索引idx所指的数据 
					  operator[];	//返回索引idx所致的数据 
					  front();		//返回容器中的第一个数据元素 
					  back();		//返回容器中的最后一个数据元素 
				
		3.3.7 deque排序
			
			功能描述：利用算法实现对deque容器进行排序
			
			算法：sort(iterator beg, iterator end); //对beg和end区间内元素进行排序(默认排序为从小到大)
													//使用algorithm中的sort()函数对容器进行排序		
				
			总结：！！！对于支持随机访问的迭代器容器，都可以利用sort算法直接对其进行排序
						vector容器也可以利用sort算法进行排序 
				
				
		
	3.5	stack容器
		
		3.5.1 stack基本概念
			
			概念：stack是一种先进后出(First In Last Out, FILO)的数据结构，它只有一个出口	
			
			栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为 
			
			栈中进入数据称为 --- 入栈（push）
			栈中弹出数据称为 --- 出栈pop（） 
			
			栈可以判读容器是否为空？ 可以，使用empty()函数
			栈可以返回元素个数吗？   可以，使用size()函数 
			
			
		3.5.2 stack常用接口
		
			功能描述：栈容器常用的对外接口
			
			构造函数：stack<T> stk;							//stack采用模板类实现，stack对象的默认构造形式 
					  stack(const stack &stk);				//拷贝构造函数 
					  
			赋值操作：stack& operator=(const stack &stk);	//重载等号运算符，进行赋值操作 
			
			数据存取：push(elem);							//向栈中添加元素elem 
					  pop();								//从栈中顶部移除第一个元素 
					  top();								//返回栈顶元素 
					  
			大小操作：empty();								//判断栈是否为空 
					  size();								//返回栈的大小 
			
	
	3.6 queue 容器
		
		3.6.1 queue基本概念：Queue是一种先进先出(First In First Out, FIFO)的数据结构，它有两个出口	
			
			队列容器允许从一端新增元素，从另一端移除元素
			
			队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为
			
			队列中进数据称为---入队(push)
			队列中移除数据称为---出队(pop)	
			 
		3.6.2 queue常用接口
		
			构造函数：queue<T> que;							//queue采用模板类实现，queue对象的默认构造形式 
					  queue(const queue &que);				//拷贝构造函数 
					  
		 	赋值操作：queue& operator=(const queue &que);	//重载等号运算符 
			
			数据存取：push(elem);							//往队尾添加elem元素 
					  pop();								//从对头移除第一个元素 
					  back();								//返回最后一个元素 
					  front();								//返回第一个元素 
					  
			大小操作：empty(); 								//判断队列是否为空 
					  size();								//返回队列的大小 
	
		
	3.7 list容器
		
		3.7.1 list基本概念：
			
			功能：将数据进行链式存储
			
			链表（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的 
		
			链表的组成：链表由一系列结点组成
			
			节点的组成：一个是存储数据元素的数据域，另一个是存储下一个节点地址的指针域
			
			STL中的链表是一个双向链表 
			
			由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器 
			
			list的优点：采用动态存储分配，不会造成内存浪费和溢出；
						链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素 
			
			list的缺点：链表灵活，但是空间(指针域)和时间(遍历)额外耗费较大
			
			List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。
			
			总结：STL中List和vector是两个最常用的容器，各有优缺点
			
		3.7.2 list构造函数
			
			功能描述：创建list容器
			
			函数原型：list<T> lst;				//创建list容器，默认构造函数 
					  list(beg, end);			//将[beg,end)区间中的数据元素赋值给创建的list容器 
					  list(n, elem);			//将n个elem元素赋值给list容器中 
					  list(const list &lst); 	//拷贝构造函数 
		
		3.7.3 list赋值和交换
			
			功能描述：给list容器进行赋值，以及交换list容器
			
			函数原型：assign(beg, end);					//将区间[beg,end)中的元素数据赋值给构造的list容器 
					  assign(n, elem);					//将n个elem元素赋值给容器 
					  list& operator=(const list &lst);	//重载等号运算符，进行赋值 
					  swap(list); 						//交换容器中的元素 
		
		
		3.7.4 list大小操作
			
			功能描述：对list容器的大小进行操作
			
			函数原型：size();				//返回队列的大小 
					  empty();				//判断队列是否为空，如果为空，则返回true 
					  resize(num);			//重新设定队列的大小为num，如果num大于原来的大小，则默认填充0
					  						//如果num小于原来的数据大小，则末尾长度超出床都的元素被删除 
					  resize(num, elem); 	//重新设定队列的大小为num，如果num大于原来的大小，则填充elem 
					  						//如果num小于原来的数据大小，则末尾长度超出床都的元素被删除
		
		3.7.5 list插入和删除
		
			功能描述：对list容器进行数据的插入和删除
			
			函数原型：push_back(elem);			//在链表尾部插入元素elem
					  push_front(elem);			//在链表头部插入元素elem 
					  pop_back(elem);			//删除链表尾部的最后一个元素 
					  pop_front(elem);			//删除链表头部的第一个元素 
					  insert(pos, elem);		//在pos(pos为迭代器，只有迭代器才可以对链表或者队列进行操作)位置插入elem元素，并返回新数据的位置 
					  insert(pos, beg, end); 	//在pos位置插入[beg, end)区间中的所有数据，无返回值 
					  insert(pos, n ,elem);		//在pos位置插入n个elem元素，无返回值 
					  clear();					//清除链表中的所有数据元素 
					  
					  erase(pos);				//清除pos位置的元素 
					  erase(beg, end);			//清除[beg, end)区间中的所有元素，返回下一个数据的位置 
					  
					  remove(elem);				//删除容器中所有于elem值匹配的元素 
		
			总结： 
		
		
		3.7.6 list数据存取
		
			功能描述：对list容器中数据进行存取
			
			函数原型：front();	//返回第一个元素 
					  back(); 	//返回最后一个元素
					  
					   
			总结：	list数据存取
					list[idx]不可以用[]访问list中的容器，只能访问两端的数据，不可以随机访问
					lst.at(0); 不可以用at方式访问list容器中的数据，
					原因在于list容器本质是一个链表，不是用连续线性空间存储数据，迭代器也是不支持随机访问 
					
					利用迭代器可以访问其余元素（将迭代器++或--） 
								
					//验证迭代器不支持随机访问
					list<int>::iterator it = lst.begin();
					it++;	// 迭代器支持前向递增和后向递增，即双向访问 
					it--; 
					//it = it + 1;	// 该语句错误，说明，该迭代器不支持随机访问 
		
		
		3.7.7 list反转和排序
		
			功能描述：将容器中的元素反转，以及将容器中的数据进行排序
			
			函数原型：reverse();	//反转链表 
					  sort(); 		//链表排序，默认排序规则为从小到大
					  				//sort还有一个重载版本，可以实现降序排列（需要在sort(仿函数)中添加仿函数） 
					  
			总结：  所有不支持随机访问的迭代器，都不可以用标准算法库 
					不支持随机访问迭代器的容器，内部会提供对应的一些算法
					//sort(lst.begin(), lst.end()); // 使用标准库中的排序算法会报错 
		
		
			对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序
			
			高级排序只是在排序规则上再进行一次逻辑规则指定，并不复杂。
			
	3.8 set/multiset容器
		
		3.8.1 set基本概念
			
			简介：所有元素都会在插入时自动被排序
			
			本质：set/multiset属于关联式容器，底层结构使用二叉树实现的
			
			set和multiset的区别：set不允许容器中有重复的元素
								 multiset允许容器中有重复的元素
								 
		3.8.2 set构造和赋值 
				
			功能描述：创建set容器以及赋值
			
			构造函数：set<T> st;			//默认构造函数 
					  set(const set &st); 	//拷贝构造函数
					  
			赋值函数：set operator=(const set &st); //重载等号运算符 
			
		3.8.3 set大小和交换 
			
			功能描述：统计set容器大小以及交换set容器
			
			函数原型：size();	//返回容器中元素的数目 
					  empty();	//判断容器是否为空 
					  swap(st);	//交换st容器和创建容器的数据 
			
		3.8.4 set插入和删除
		
			功能描述：set容器进行插入数据和删除数据
			
			函数原型：inset(elem);		//在容器中插入元素 
					  clear();			//清空容器中的所有数据 
					  erase(pos);		//删除pos位置所指的数据，返回下一个元素的迭代器 
					  erase(beg, end);	//清除[beg, end)区间中的所有数据，返回下一个元素的迭代器 
					  erase(elem); 		//删除所有值为elem的元素 
		3.8.5 set查找和统计
		
			功能描述：对set容器进行查找数据以及统计数据
			
			函数原型：find(key);	//查找key是否存在。若存在，则返回该键的元素的迭代器了；若不存在，则返回set.end();  
					  count(key);	//统计key的元素个数 
			
			
		3.8.6 set和multiset的区别：
			
			学习目标：掌握set和multiset的区别。
			
			区别：set不可以插入重复数据，而multiset可以插入重复数据
				  set插入数据的同时会返回插入结果，表示插入是否成功
				  multiset不会检测数据，因此可以插入重复数据	
			
			
		3.8.7 pair对组创建
		
			功能描述：成对出现的数据，利用对组可以返回两个数据
			
			两种创建方式：pair<type, type> p (value1, value2);
						  pair<type, type> p = make_pair(value1, value2);		
			
			
		3.8.8 set容器排序
			
			学习目标：set容器默认排序规则为从小到大，掌握如何改变排序规则
			
			主要技术点：利用仿函数，可以改变排序规则
			
			总结：利用仿函数可以指定set容器的排序规则
				
				   set容器在进行插入时，就已经排序，排序后元素位置不可再更改，因此如果想要改变容器的排序规则，则需要在插入之前就改变排序规则	
			
			
			
		3.9 map/ multimap容器
		
			3.9.1 map基本概念
			
				简介：map中所有元素都是pair
					  pair中第一个元素为key（键值），起到搜索作用，第二个元素为value（实值）
					  所有元素都会根据元素的键值自动排序
				
				本质：map/multimap容器属于关联式容器，底层结构使用二叉树方式实现的
				
				优点：可以根据key值快速着地value值
				
				map和muletimap的区别:map不允许容器中有重复key值元素
									 multimap允许容器中有重复key值元素
									 
			3.9.2 map构造和赋值
			
				功能描述：对map容器进行构造和赋值操作
				
				函数原型：构造：map<T1,T2> mp;					//map默认构造函数 
						 	 	map(const map &mp);				//拷贝构造函数 
								  
						  赋值：map& operator=(const map &mp); 	//重载等号运算符 
				
				总结：map中所有元素都是成对出现的，插入数据时要使用pair对组
				
			3.9.3 map的大小和交换
			
				功能描述：统计map容器大小以及交换map容器
				
				函数原型：size();				//返回map容器的大小 
						  empty();				//判断容器是否为空 
						  swap(map<T,T> &st); 	//交换st容器和创建的容器的元素 
				
				
			3.9.4 map插入和删除
			
				功能描述：map容器进行插入数据和删除数据
				
				函数原型：insert(elem);		//在容器中插入元素 
						  clear();			//删除容器中的所有元素 
						  erase(pos);		//删除pos迭代器所指的元素，并返回下一个元素的迭代器 
						  erase(beg, end);	//删除[beg, end)区间中的所有元素，并返回下一个元素的迭代器 
						  erase(key); 		//删除容器中值为key的所有元素 
				
				
				总结：// 第一种插入方式 
					  mp.insert(pair<int, int>(1, 10)); 
					  mp.insert(pair<int, int>(1, 110)); 	// 插入失败，map容器中不允许有相同的key值 
					  mp.insert(pair<int, int>(6, 10)); 	// 插入成功，允许有相同的value值 
	
					  // 第二种插入方式（推荐使用该种方法） 
					  mp.insert(make_pair(7,77));
					
					  // 第三种插入方式
					  mp.insert(map<int, int>::value_type(8,88));
					
					  // 第四种插入方式---不建议使用该种方式 
					  mp[9] = 99;
				
					  // 如果打印的mp[key]元素中，键值为key的元素不存在，则编译器自动创建mp[key] = 0
					  // mp[key]该种方法可以通过key值访问到value值 
				
				
				3.9.5 map查找和统计
				
					功能描述：对map容器进行查找数据以及统计数据
					
					函数原型：find(key);	//查找键值为key的元素是否存在 
							  count(key); 	//统计键值为key的元素的个数 
				
					总结：// map中不允许插入重复的键值，因此mp.count(key)的返回值为1或0
						  // multtimap可以插入重复的键值，因此返回值可以大于1  
				
				3.9.6 map容器排序
					
					学习目标：map容器默认排序规则为：按照key值进行从小到大排序，掌握如何改变排序规则
					
					主要技术点：利用仿函数，可以改变排序规则	
				
					总结：利用仿函数可以指定map容器的排序规则
						  但对于自定义数据类型，map必须要指定排序规则，同set容器 
				
				
				
				
4、STL函数对象
	
	4.1 函数对象
		
		4.1.1 函数对象概念：
			
			概念：重载 函数调用操作符 的类，其对象常称为函数对象
				  函数对象 使用重载的()时，行为类似函数调用，也叫仿函数
				  
			本质：函数对象(仿函数)是一个类，不是一个函数
			
		4.1.2 函数对象使用
		
			特点：函数对象在使用时，可以像普通函数那样调用，也可以有参数，可以有返回值
				  函数对象超出普通函数的概念，函数对象可以有自己的状态
				  函数对象可以作为参数传递				
				
				
			总结：仿函数写法非常灵活，可以作为参数进行传递。
			
	4.2 谓词
		
		4.2.1 谓词概念	
			
			概念：返回bool类型的仿函数称为 谓词
				  如果operator()接收一个参数，那么叫做一元谓词
				  如果operator()接收两个参数，那么叫做二元谓词
			 
				
	4.3 内建函数
		
		4.3.1 内建函数
			
			概念：STL内建了一些函数对象
			
			分类：算术仿函数、关系仿函数、逻辑仿函数
			
			用法：这些仿函数所产生的对象，用法和一般函数完全相同
				  使用内建函数对象，需要引入头文件#include<functional>
				  
		4.3.2 算术仿函数
		
			功能描述：实现四则运算，其中neagte是一元运算，其他都是二元运算
			
			仿函数原型：template<class T> T plus<T>			//加法仿函数 
						template<class T> T minus<T>		//减法仿函数 
						template<class T> T multiplies<T>	//乘法仿函数 
						template<class T> T divides<T>		//除法仿函数 
						template<class T> T modulus<T>		//取模仿函数 
						template<class T> T negate<T>		//取反仿函数 
				
				
		4.3.3 关系仿函数
			
			功能描述：实现关系对比
			
			仿函数原型：template<class T> bool equal_to<T>		//等于 
						template<class T> bool not_equal_to<T>	//不等于 
						template<class T> bool grater<T>		//大于 
						template<class T> bool grater_equal<T>	//大于等于 
						template<class T> bool less<T>			//小于 
						template<class T> bool less_equal<T>	//小于等于 
				
				
			总结：关系仿函数中最常用的就是greater<>大于函数
			
		4.3.4 逻辑仿函数
		
			功能描述：实现逻辑运算
			
			函数原型：template<class T> bool logical_and<T>	//逻辑与 
					  template<class T> bool logicak_or<T>	//逻辑或 
					  template<class T> bool logical_not<T> //逻辑非 
				
				
			总结：逻辑仿函数实际应用较少，了解即可	
				
				
5、STL-常用算法

	概述：算法主要是由头文件<algorithm>、<functional>、<numeric>组成
	
	<algorithm>是所有STL头文件中最大的一个，范围涉及到比较、交换、查找、遍历操作、复制、修改等等
	<numeric>体积很小，只包括几个在序列上面进行见到数学运算的模板函数
	<functional>定义了一些模板类，用以声明函数对象
	
	5.1 常用遍历算法 
		
		学习目标：掌握常用的遍历算法
		
		算法简介：for_eack;	  //遍历容器 
				  transform;  //搬运容器到另一个容器中
		
		5.1.1 for_each
			
			功能描述：实现遍历容器
			
			函数原型：for_each(itertor beg, iterator end, _func);	//遍历算法，遍历容器元素
																	//beg为起始迭代器，end为结束迭代器，_func为函数或函数对象 
			 
			总结：for_each在实际开发中是最常用的遍历函数，需要熟练掌握														
		
		5.1.2 transform
			
			功能描述：搬运容器到另一个容器中
			
			函数原型：transform(iterator beg1, iterator end1, iterator beg2, _func);
					  //beg1为源容器开始迭代器，end1为源容器结束迭代器，beg2为目标容器开始迭代器，_func为函数或者函数对象
					  
			总结：搬运的目标容器必须要提前开辟空间，否则无法正常运行
		
	
	5.2 常用的查找算法
	
		学习目标：掌握常用的查找算法
		
		算法简介：find			//查找元素 
				  find_if		//按条件查找元素 
				  adjacent_find	//查找相邻重复元素 
				  binary_search	//二分查找法 
				  count			//统计元素个数 
				  count_if 		//按条件统计元素个数 
		
		5.2.1 find
			
			功能描述：查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()
			
			函数原型：find(iterator beg, iterator end, value); //按值查找元素，找到则返回位置迭代器，找不到则返回结束迭代器位置
															   //beg：开始迭代器；end：结束迭代器；value：查找的元素 
			总结：利用find可以在容器中查找指定的元素，返回值为迭代器
			
		5.2.2 find_if
		
			功能描述：按条件查找元素
			
			函数原型：find_if(iterator bed, iterator end, _Pred);	//按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置
																	//beg为起始迭代器位置，end为结束迭代器位置，_Pred为函数或者谓词（返回bool类型的仿函数）
		5.2.3 adjacent_find
			
			功能描述：查找相邻重复元素
			
			函数原型：adjacent_find(iterator beg, iterator end);	//查找相邻重复元素，返回相邻元素的第一个位置的迭代器
																	//beg开始迭代器，end为结束迭代器															 
			总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法 
		
		5.2.4 binary_search
		
			功能描述：查找指定元素是否存在
			
			函数原型：bool binary_search(iterator beg, iterattor end, value);
					  // 查找指定的元素，查到返回true，否则返回false
					  // 注意：在无序序列中不可用
					  // beg开始迭代器，end结束迭代器，value查找的元素 
			
			总结：二分查找效率很高，但是容器中的元素序列必须有序排序，否则无法保证查询结果是否正确
			
		5.2.5 count
			
			功能描述：统计元素个数
			
			函数原型：count(iterator beg, iterator end, value);	//统计元素出现的次数
																//beg开始迭代器，end结束迭代器，value查找的值
			总结：对于统计自定义数据类型的时候，需要配合重载operator==
			
		5.2.6 count_if
			
			功能描述：按条件统计元素个数
			
			函数原型：count_if(iterator beg, iterator end, _Pred);	//按条件统计元素出现次数
																	//bed为其实迭代器，end为结束迭代器，_Pred为谓词 
			
			总结：
			
	5.3 常用排序算法
	
		学习目标：掌握常用的排序算法
		
		算法简介：sort				//对容器内元素进行排序 
				  random_shuffle	//洗牌 指定范围内的元素随机调整次序 
				  merge				//容器元素合并，并存储到另一个容器中 
				  reverse 			//反转指定范围的元素
		
		5.3.1 sort
			
			功能描述：对容器内元素进行排序
			
			函数原型：sort(iterator beg, iterator end, _Pred);	//排序算法，找到返回指定位置迭代器，找不到返回结束位置迭代器
																//beg开始迭代器，end结束迭代器，_Pred为谓词 
									
			总结：sort属于开发中最常用的算法之一，要数量掌握						 
						 
		5.3.2 random_shuffle
			
			功能描述：指定范围内的元素随机调整次序
			
			函数原型：random_shuffle(iterator beg, iterator end); //指定范围内的元素随机调整次序
			
			总结：random_shuffle洗牌算法比较实用，使用时记得加随机种子,要不每次随机结果相同 
	
	
	  	5.3.3 merge
		  
		  	功能描述：两个容器合并，并存储到另一个容器三
			  
			函数原型：merge(iterator beg1, iterator end, iterator beg2, iterator end2, iterator dest);
					  //两个容器合并，并存储到另一容器中
					  //！！！！！！注意：两个容器必须是有序的，且两个容器的排序方式相同！！！！！！！！
					  //beg1：容器1开始迭代器，end1：容器1结束迭代器，
					  //beg2：容器2开始迭代器，end2：容器2结束迭代器
					  //dest：目标容器开始迭代器 
				
			总结：merge合并的两个容器必须是有序序列	
			
		5.3.4 reverse
			
			功能描述：将容器内的元素反转
			
			函数原型：reversr(iterator beg, iterator end);//反转指定范围就在的元素
			
			总结：reverse反转区间内元素，面试中可能会用到
	
	5.4 常用拷贝和替换算法
	
		学习目标：掌握常用的拷贝和替换算法
		
		算法简介：copy			//容器内指定范围的元素拷贝到另一容器中 
				  replace 		//将容器内指定范围的旧元素修改为新元素 
				  replace_if	//容器内指定范围满足条件的元素替换为新元素 
				  swap 			//互换两个容器的元素
		
		5.4.1 copy
			
			功能描述：将容器内指定范围的元素拷贝到另一容器中
			
			函数原型：copy(iterator beg, iterator end, iterator dest);//将指定范围内的元素拷贝到dest目标容器中 
				  
			总结：利用copy算法在拷贝时，目标容器记得提前开辟空间
		
		5.4.2 replace
			
			功能描述：将容器内指定范围的旧元素改为新元素
			
			函数原型：replace(iterator beg, iteratoe end, oldvalue, newvalue);	//将区间中的就旧元素替换为新元素
			
			总结：replace会替换区间内满足条件的元素
			
		5.4.3 replace_if
		
			功能描述：将容器内指定范围中满足条件的旧元素替换为新元素  
			
			函数原型：replace_if(iterator beg, iterator end, _pred, newvalue);	//按条件替换元素，满足条件的替换成指定元素，_pred为谓词 
				  
			总结：replace_if按条件查找，可以利用仿函数灵活筛选满足的有条件	  
		
		5.4.4 swap
		
			功能描述：互换两个容器的元素
			
			函数原型：swap(container c1, container c2);	//互换两个容器的元素，c1为容器1，c2为容器2
			
			总结：注意，互换的容器需要为相同的类型
	
	5.5 常用算术生成算法
	
		学习目标：掌握常用的算术生成算法
		
		注意：算术生成算法属于小型算法，使用时包含头文件 #include<numeric>
		
		算法简介：accumulate	//计算容器元素累计总和
				  fill			//向容器中添加元素
				  
		
		5.1.1 accumulate
		
			功能描述：计算区间内 容器元素累计总和
			
			算法简介：accumulate(iterator beg, iterator end, value);	//计算容器元素累计总和
																		//[beg,end)为起始迭代器和结束迭代器，vaule为起始值 
				  
			总结：accumulate使用时头文件注意是 numeric ，这个算法很实用	  
		
		5.1.2 fill
			
			功能描述：向容器中填充指定的元素
			
			算法简介：fill(iterator beg, iterator end, value); 	//像容器中填充value元素 
				  
			总结：利用fill可以将容器区间内的元素填充为指定的值	  
				  
	5.6 常用集合算法
	
		学习目标：掌握常用的集合算法
		
		算法简介：set_intersection	//求两个容器的交集 
				  set_union			//求两个容器的并集 
				  set_difference	//求两个容器的差集
				  
		5.6.1 set_intersection
			
			功能描述：求两个容器的交集
			
			函数原型：set_itersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);
					  // 求两个容器的交集
					  //！！！！！注意：两个集合必须是有序序列！！@！@！ 
				 	  // beg1,end1分别为容器1的开始迭代器和结束迭代器
					  // beg2,end2分别为容器2的开始迭代器和结束迭代器
					  // set_itersction会返回迭代器，该迭代器的位置是交集最后的位置 
					   
			总结：1、求交集的两个集合必须是有序序列
				  2、目标容器开辟空间需要从两个容器中取最小值
				  3、set_intersection返回值是交集中最后一个元素的位置 
				  
		5.6.2 set_union
		
			功能描述：求两个集合的并集
			
			函数原型：set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);
					  //求两个集合的并集
					  //beg1和end1为容器1的开始迭代器和结束迭代器 
					  //beg3和end3为容器2的开始迭代器和结束迭代器 
					  //dest为目标容器开始迭代器 
		
			总结：求并集的两个集合必须是有序序列
				  目标容器开辟空间需要两个容器相机
				  set_union返回值 是并集个最后一个元素的位置 
		
		5.6.3 set_difference 
		
			功能描述：求两个集合的差集
			
			函数原型：set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); 
					  //求两个集合的差集
					  // ！！！！！注意：两个集合必须是有序序列！！！！！
					  //beg1和end1为容器1的开始迭代器和结束迭代器 
					  //beg3和end3为容器2的开始迭代器和结束迭代器 
					  //dest为目标容器开始迭代器 
			
			总结：求差集的两个集合必须为有序序列 
				  目标容器开辟空间需要从两个容器中取较大值
				  set_difference返回值为 差集中最后一个元素的位置 
		
		
		
		
		 
					  
				  
				   
